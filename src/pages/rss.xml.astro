---
import rss from '@astrojs/rss';
import { getCollection } from 'astro:content';
import { SITE_NAME, SITE_TITLE } from '../consts';
import {
  getAllTags,
  getAllAuthors,
  tagToSlug,
  authorToSlug,
  getTagBySlug,
} from '../lib/news';

const site = import.meta.env.SITE || 'https://pwv.com';

const allPosts = (await getCollection('posts')).sort((a, b) => {
  const dateA = new Date(a.data.pubDate).getTime();
  const dateB = new Date(b.data.pubDate).getTime();
  return dateB - dateA;
});

// Normalize site URL (no trailing slash)
const siteUrl = String(site).replace(/\/$/, '');

// Generate listing page items
const newsTags = await getAllTags();
const newsAuthors = await getAllAuthors();

const newsTagItems = await Promise.all(
  newsTags.map(async (tag) => {
    const tagSlug = tagToSlug(tag);
    // Get original tag name with proper capitalization
    const originalTag = await getTagBySlug(tagSlug) || tag;
    const tagURL = `${siteUrl}/news/tags/${tagSlug}`;
    return {
      title: `News tagged "${originalTag}"`,
      description: `Browse all articles and posts tagged "${originalTag}" on PWV.`,
      link: tagURL,
      guid: tagURL,
      pubDate: new Date(), // Use current date for listing pages
      categories: [originalTag],
    };
  })
);

const newsAuthorItems = newsAuthors.map((author) => {
  const authorSlug = authorToSlug(author);
  const authorURL = `${siteUrl}/news/author/${authorSlug}`;
  return {
    title: `News by ${author}`,
    description: `Browse all articles and posts by ${author} on PWV.`,
    link: authorURL,
    guid: authorURL,
    pubDate: new Date(), // Use current date for listing pages
    categories: [author],
  };
});

// Generate portfolio tag items
const [rolling, angel, fund1] = await Promise.all([
  getCollection('rollingFundPortfolio'),
  getCollection('angelPortfolio'),
  getCollection('fundOnePortfolio'),
]);

const mergedMap = new Map<string, any>();
for (const entry of [...rolling, ...angel, ...fund1]) {
  mergedMap.set(entry.data.slug, entry);
}
const companies = Array.from(mergedMap.values());

const portfolioTags = Array.from(
  new Set(
    companies.flatMap((c) =>
      (c.data.tags || []).map((t: string) => t.toLowerCase())
    )
  )
);

const portfolioTagItems = portfolioTags.map((tag) => {
  const tagURL = `${siteUrl}/portfolio/tags/${encodeURIComponent(tag)}`;
  return {
    title: `Portfolio tagged "${tag}"`,
    description: `Browse all portfolio companies tagged "${tag}" on PWV.`,
    link: tagURL,
    guid: tagURL,
    pubDate: new Date(), // Use current date for listing pages
    categories: [tag],
  };
});

const rssContent = await rss({
  title: `${SITE_NAME} - ${SITE_TITLE}`,
  description: `Latest news from PWV and our founder community`,
  site: siteUrl,
  xmlns: {
    atom: 'http://www.w3.org/2005/Atom',
  },
  items: [
    ...allPosts.map((post) => {
    // always use the internal post URL
    const postURL = `${siteUrl}/news/${post.id}`;

    // Create canonical URL for hero image if it exists
    const heroImageData = post.data.heroImage
      ? (() => {
          const rawSrc =
            typeof post.data.heroImage === 'object' &&
            post.data.heroImage !== null
              ? ((post.data.heroImage as any).src ?? post.data.heroImage)
              : post.data.heroImage;

          if (typeof rawSrc !== 'string') return undefined;

          // Build absolute base URL (no trailing slash)
          const base = siteUrl;

          // Ensure an absolute source URL for Netlify Images url param
          const absoluteSrc = rawSrc.startsWith('http')
            ? rawSrc
            : rawSrc.startsWith('/')
              ? `${base}${rawSrc}`
              : `${base}/${rawSrc}`;

          // Netlify Images proxy (keep as jpeg for best compatibility in RSS readers)
          const encoded = encodeURIComponent(absoluteSrc);
          const netlifyImgUrl = `${base}/.netlify/images?url=${encoded}&w=1200&h=630&fit=cover&fm=jpg`;

          return {
            url: netlifyImgUrl,
            type: 'image/jpeg',
            // Approximate length for a 1200x630 JPEG image (required by RSS spec)
            length: '150000',
          };
        })()
      : undefined;

    return {
      title: post.data.title,
      description: post.data.description,
      pubDate: post.data.pubDate,
      link: postURL,
      guid: postURL,
      // Remove author field since we don't have email addresses
      // RSS 2.0 requires author to be in format: email@example.com (Name)
      categories: post.data.tags,
      customData: heroImageData
        ? `<enclosure url="${heroImageData.url}" type="${heroImageData.type}" length="${heroImageData.length}" />`
        : '',
    };
  }),
  ...newsTagItems,
  ...newsAuthorItems,
  ...portfolioTagItems,
  ],
  customData: `<language>en</language>
    <atom:link href="${siteUrl}/rss.xml" rel="self" type="application/rss+xml" />`,
});

const xmlContent = await rssContent.text();
---

<Fragment set:html={xmlContent} />
