---
import Layout from '../../layouts/Layout.astro';
import Heading1 from '../../components/Heading1.astro';
import Heading2NoUnderline from '../../components/Heading2NoUnderline.astro';
import LinkedInLink from '../../components/LinkedInLink.astro';
import TwitterLink from '../../components/TwitterLink.astro';
import GitHubLink from '../../components/GitHubLink.astro';
import BlueskyLink from '../../components/BlueskyLink.astro';
import WebsiteLink from '../../components/WebsiteLink.astro';
import PostsGrid from '../../components/PostsGrid.astro';
import { getCollection } from 'astro:content';
import { getPostsByAuthor, getPostsByTag } from '../../lib/news';
import { marked } from 'marked';
import {
  generatePersonSchema,
  generateBreadcrumbListSchema,
  generateItemListSchema,
} from '../../lib/schema';
import { SITE_NAME } from '../../consts';

export async function getStaticPaths() {
  const teamMembers = await getCollection('team');

  // Only generate paths for team members with hasPage: true
  return teamMembers
    .filter((member) => member.data.hasPage === true)
    .map((member) => ({
      params: { slug: member.data.slug },
      props: { member },
    }));
}

const { member } = Astro.props;

if (!member || !member.data.hasPage) {
  return Astro.redirect('/404');
}

// Helper function to parse frontmatter and content from markdown
function parseMarkdown(markdown: string) {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
  const match = markdown.match(frontmatterRegex);

  if (match) {
    const frontmatter = match[1];
    const content = match[2];
    return { frontmatter, content };
  }

  // If no frontmatter, return the whole thing as content
  return { frontmatter: '', content: markdown };
}

// Try to load markdown file for this team member (only the specific file)
let markdownContent: string | null = null;
const targetSlug = member.data.slug;

// Load only the specific markdown file for this team member using dynamic import
try {
  const markdownModule = await import(
    `../../content/team/${targetSlug}.md?raw`
  );

  // With ?raw query, Vite returns the content as default export
  const rawMarkdown =
    typeof markdownModule === 'string'
      ? markdownModule
      : markdownModule.default || markdownModule;

  if (typeof rawMarkdown === 'string' && rawMarkdown) {
    const { content } = parseMarkdown(rawMarkdown);
    markdownContent = marked.parse(content.trim()) as string;
  }
} catch (error) {
  // Markdown file doesn't exist for this team member, which is fine
  markdownContent = null;
}

const {
  name,
  title,
  bio,
  hoverLine,
  linkedin,
  twitter,
  github,
  bluesky,
  website,
  includePosts,
  authorName,
} = member.data;

// Get posts by this author if they have includePosts enabled
// also add posts where their name is in tags
// then sort by publication date
let authorPosts: any[] = [];
if (includePosts && authorName) {
  authorPosts = await getPostsByAuthor(authorName);
}

// Get posts where the team member's name appears in tags
const postsByTag = await getPostsByTag(name);

// Combine both arrays and remove duplicates by post ID using a Map
const postsMap = new Map();
[...authorPosts, ...postsByTag].forEach((post) => {
  if (!postsMap.has(post.id)) {
    postsMap.set(post.id, post);
  }
});

// Convert Map values to array and sort by publication date (newest first)
const sortedPosts = Array.from(postsMap.values()).sort(
  (a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf()
);

// SEO-optimized title and description
const pageTitle = `${name} - ${title} | PWV`;
// Use hoverLine as primary description if available, otherwise use a shortened bio
const description =
  hoverLine || (bio.length > 160 ? `${bio.substring(0, 157)}...` : bio);
const keywords = `${name}, ${title}, PWV, venture capital, early-stage investing, general partner`;

// Get base URL for schema generation
export const isProduction = process.env.CONTEXT === 'production';
export const isDeployPreview = process.env.CONTEXT === 'deploy-preview';
const baseURL = isDeployPreview
  ? process.env.DEPLOY_PRIME_URL || Astro.site
  : Astro.site;
const canonicalURL = new URL(Astro.url.pathname, baseURL);

// Build sameAs array for social profiles
const sameAs: string[] = [];
if (member.data.github) {
  sameAs.push(`https://github.com/${member.data.github}`);
}
if (member.data.linkedin) {
  sameAs.push(`https://www.linkedin.com/in/${member.data.linkedin}`);
}
if (member.data.twitter) {
  sameAs.push(`https://x.com/${member.data.twitter}`);
}
if (member.data.bluesky) {
  // Handle both Bluesky handles and custom domains
  const blueskyUrl = member.data.bluesky.startsWith('http')
    ? member.data.bluesky
    : `https://bsky.app/profile/${member.data.bluesky}`;
  sameAs.push(blueskyUrl);
}
if (member.data.website) {
  sameAs.push(member.data.website);
}

// Add PWV website
const organizationUrl = baseURL?.toString() || canonicalURL.toString();
sameAs.push(organizationUrl);

// Add Wikipedia link for Tom Preston-Werner
if (member.data.slug === 'tom-preston-werner') {
  sameAs.push('https://en.wikipedia.org/wiki/Tom_Preston-Werner');
}

// Generate Person schema with full URL @id
const personId = new URL(
  `/team/${member.data.slug}#person`,
  baseURL || canonicalURL
).toString();

// Use givenName/familyName from data, or parse from name
const givenName = member.data.givenName || member.data.name.split(' ')[0];
const familyName =
  member.data.familyName ||
  (() => {
    const nameParts = member.data.name.split(' ');
    if (nameParts.length > 1) {
      let family = nameParts.slice(1).join(' ');
      // Remove parenthetical content (e.g., "(DT)")
      family = family.replace(/\s*\([^)]*\)\s*/g, '').trim();
      return family || undefined;
    }
    return undefined;
  })();

// Build person URL
const personUrl = new URL(
  `/team/${member.data.slug}`,
  baseURL || canonicalURL
).toString();

// Organization @id reference (full URL format)
const organizationId = new URL(
  '#organization',
  baseURL || canonicalURL
).toString();

// Build schema options from member data
const schemaOptions: any = {
  id: personId,
  name: member.data.name,
  givenName: givenName,
  familyName: familyName || undefined,
  jobTitle: member.data.schemaJobTitle || member.data.title,
  description: member.data.schemaDescription || member.data.bio,
  url: personUrl,
  sameAs: sameAs.length > 0 ? sameAs : undefined,
  worksFor: {
    name: SITE_NAME,
    url: organizationUrl,
    id: organizationId,
  },
};

// Add image if provided
if (member.data.schemaImage) {
  schemaOptions.image = new URL(
    member.data.schemaImage,
    baseURL || canonicalURL
  ).toString();
}

// Add optional fields from member data
if (member.data.affiliation && member.data.affiliation.length > 0) {
  schemaOptions.affiliation = member.data.affiliation;
}

if (member.data.knowsAbout && member.data.knowsAbout.length > 0) {
  schemaOptions.knowsAbout = member.data.knowsAbout;
}

if (member.data.nationality) {
  schemaOptions.nationality = member.data.nationality;
}

if (member.data.alumniOf && member.data.alumniOf.length > 0) {
  schemaOptions.alumniOf = member.data.alumniOf;
}

if (member.data.homeLocation) {
  schemaOptions.homeLocation = member.data.homeLocation;
}

// Generate Person schema
const personSchema = generatePersonSchema(schemaOptions);

// Generate BreadcrumbList schema
const breadcrumbItems = [
  { name: 'Home', url: new URL('/', baseURL).toString() },
  { name: 'About', url: new URL('/about', baseURL).toString() },
  { name: member.data.name, url: canonicalURL.toString() },
];
const breadcrumbSchema = generateBreadcrumbListSchema({
  items: breadcrumbItems,
});

// Generate ItemList schema for articles by this team member (only if there are posts)
let itemListSchema: any = null;
if (sortedPosts.length > 0) {
  const itemListItems = sortedPosts.map((post) => {
    const postUrl = new URL(`/news/${post.id}`, baseURL).toString();
    let postImage: string | undefined;

    if (post.data.heroImage) {
      if (typeof post.data.heroImage === 'string') {
        postImage = post.data.heroImage.startsWith('/')
          ? new URL(post.data.heroImage, baseURL).toString()
          : undefined;
      } else if (
        typeof post.data.heroImage === 'object' &&
        post.data.heroImage !== null &&
        'src' in post.data.heroImage
      ) {
        const src = (post.data.heroImage as any).src;
        postImage =
          typeof src === 'string' && src.startsWith('/')
            ? new URL(src, baseURL).toString()
            : undefined;
      }
    }

    return {
      '@type': post.data.url ? 'NewsArticle' : 'BlogPosting',
      name: post.data.title,
      url: postUrl,
      description: post.data.description,
      ...(postImage && { image: postImage }),
      datePublished: post.data.pubDate.toISOString(),
    };
  });

  itemListSchema = generateItemListSchema({
    name: `Articles by ${member.data.name}`,
    description: `Articles and posts by ${member.data.name}`,
    url: canonicalURL.toString(),
    items: itemListItems,
    numberOfItems: sortedPosts.length,
  });
}
---

<Layout
  title={pageTitle}
  description={description}
  keywords={keywords}
  author={name}
  enableUTMTracking={true}
  contentType="team"
  contentSlug={member.data.slug}
  additionalSchemas={[
    { schema: personSchema },
    { schema: breadcrumbSchema },
    ...(itemListSchema ? [{ schema: itemListSchema }] : []),
  ]}
>
  <section class="mx-auto space-y-4">
    <Heading1>{name}</Heading1>

    <Heading2NoUnderline>{title}</Heading2NoUnderline>
  </section>

  <p class="mt-6 max-w-screen-md text-lg leading-relaxed">
    {bio}
  </p>

  <!-- Social Links -->
  {
    (linkedin || twitter || github || bluesky || website) && (
      <div class="mt-6 flex gap-3">
        {linkedin && <LinkedInLink handle={linkedin} />}
        {twitter && <TwitterLink handle={twitter} />}
        {bluesky && <BlueskyLink handle={bluesky} />}
        {github && <GitHubLink handle={github} />}
        {website && <WebsiteLink url={website} />}
      </div>
    )
  }

  <!-- Markdown Content -->
  {
    markdownContent && (
      <div
        class="prose prose-lg mt-8 max-w-screen-lg leading-relaxed"
        set:html={markdownContent}
      />
    )
  }

  {
    sortedPosts.length > 0 && (
      <section class="mt-12 space-y-6">
        <Heading2NoUnderline>Articles by {name}</Heading2NoUnderline>
        <PostsGrid posts={sortedPosts} size="large" />
      </section>
    )
  }

  <div class="mt-12 text-center">
    <a
      href="/about"
      class="bg-pwv-black text-pwv-white inline-flex items-center gap-2 rounded-lg px-5 py-2 text-sm"
    >
      <svg
        class="h-4 w-4"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M15 19l-7-7 7-7"></path>
      </svg>
      Back to Team
    </a>
  </div>
</Layout>
